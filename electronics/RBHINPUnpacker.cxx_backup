//#include <config.h>
#include <stdint.h>
#include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <string>

#include "RBHINPUnpacker.h"

using namespace std;

const Int_t XLM1 =  0x1ff3;
const Int_t XLM2 =  0x2ff3;
const Int_t nXLMs = 1;

static UInt_t numChips;

TClonesArray *RBHINPUnpacker::fgHits = 0;

//______________________________________________________________________________
RBHINPUnpacker::RBHINPUnpacker(const char* name, Int_t nMBs, Bool_t usingSISFADC)
:fFoundBeginMarker(0),fReportNExtraMarkers(0)
{
  // --
  //
  
  SetGeo(-1);
  fnMBs         = nMBs;
  fBankMB[0]    = -1;
  fBankMB[1]    = -1;
  fUsingSISFADC = usingSISFADC;
  
  if(!fgHits) fgHits = new TClonesArray("RBHINPHit",10);
  fHits  = fgHits;
  fNHits = 0;
}


//______________________________________________________________________________
RBHINPUnpacker::~RBHINPUnpacker()
{
  // --
  //
  
  Clear();
}


//______________________________________________________________________________
void RBHINPUnpacker::Clear(Option_t */*option*/)
{
  // --
  //

  if(fHits) fHits->Clear("C");
  fNHits = 0;
}


//______________________________________________________________________________
void RBHINPUnpacker::InitBranch(TTree *tree)
{
  // --
  //
  
  if(GetFillData()){
    Char_t tmp[500];
    //sprintf(tmp,"%s[%i]/s",fChName.Data(),fnCh);
    //tree->Branch(fChName, fData, tmp);
    tree->Branch(TString(GetName())+".fHits","TClonesArray",&fHits,32000,99);
  }else{
    cout << "-->RBHINPUnpacker::InitBranch  Branches will not be created or filled." << endl;
  }
}


//______________________________________________________________________________
void RBHINPUnpacker::InitTree(TTree *tree)
{
  // --
  //
  
  fChain = tree;
}


//______________________________________________________________________________
Int_t RBHINPUnpacker::GetBankMB(char bank)
{
  // --
  //
  
  if     (bank=='A') return fBankMB[0];
  else if(bank=='B') return fBankMB[1];
  else cerr << "-->RBHINPUnpacker::GetBankMB  Invalid XLM BANK." << endl;
  
  return -1;
}


//______________________________________________________________________________
Int_t RBHINPUnpacker::GetBankMBByIndex(Int_t bank)
{
  // --
  //
  
  if(bank==0 || bank==1) return fBankMB[bank];
  else cerr << "-->RBHINPUnpacker::GetBankMBByIndex  Invalid XLM BANK." << endl;
  
  return -1;
}


//______________________________________________________________________________
void RBHINPUnpacker::SetBankMB(char bank, Int_t mb)
{
  // -- Map the motherboard to a specific XLM BANK.
  //
  
  if(!(bank=='A' || bank=='B')) cerr << "-->RBHINPUnpacker::SetBANKMap  Invalid XLM BANK." << endl;
  else{
    if(bank == 'A') fBankMB[0] = mb;
    if(bank == 'B') fBankMB[1] = mb;
  }
}


//______________________________________________________________________________
RBHINPHit* RBHINPUnpacker::AddHit(UShort_t bank,   UShort_t ch, UShort_t chip,
                                  UShort_t energy, UShort_t time)
{
  // --
  //
  
  RBHINPHit *hit = (RBHINPHit*)fHits->ConstructedAt(fNHits);
  fNHits++;
  hit->Set(bank, ch, chip, energy, time);
  
  return hit;
}


//______________________________________________________________________________
Int_t RBHINPUnpacker::Unpack(vector<UShort_t>& event, UInt_t offset)
{
  // -- Unpacker
  //
  //
  //  ------------------------------------
  // | id 16-bits                         |
  //  ------------------------------------
  // | number of words in the bank        |
  //  ------------------------------------
  // | number of events                   |
  //  ------------------------------------
  // | tag data from XLM1 SRAMa           |
  // |...                                 |
  //  ------------------------------------
  // | number of events                   |
  //  ------------------------------------
  // | tag data from XLM1 SRAMb           |
  // |..                                  |
  //  ------------------------------------
  // | number of events                   |
  //  ------------------------------------
  // | tag data from XLM2 SRAMa           |
  // |..                                  |
  //  ------------------------------------
  // | number of events                   |
  //  ------------------------------------
  // | tag data from XLM2 SRAMb           |
  // |..                                  |
  //  ------------------------------------
  // | 0xfadc                             |
  //  ------------------------------------
  // | Mask of read groups                |
  //  ------------------------------------
  // | Data from the FADC module group1   |
  //  ------------------------------------
  // | 0xaaa                              |
  //  ------------------------------------
  // |...                                 |
  // | Data from the FADC module group2   |
  // |...                                 |
  //  ------------------------------------
  // Same for FADC module group 3,4
  //
  
  Clear();
  
  UShort_t         xlmID[10];
  ULong64_t        xlmWordCount[10];
  ULong64_t        xlmChWordCount[10];
  vector<UShort_t> channelIds16[10];
  vector<UInt_t>   channelIds32[10];
  
  //    cout << "#--->" << offset << endl;
  //    for(int zz=offset; zz<500; zz++) {printf("%0.4x ", event[zz]); if(zz%5==0 && zz!=0) cout << endl;}
  //    cout << endl;
  
  // There could be markers defined, such as the HiRA marker.
  // Skip these and find the XLM ID.
  // Markers should be unpacked properly elsewhere in the future. . .


  //The first word that shows up is right after 1ff3...which is after the b0fe marker.JJM
  //while (event[offset]!=0xb0fe){
  //  offset++;
  //  cout << "This is where I am " << hex << event[offset] << endl;
  // }

  //  cout << "This should be b0fe before test " << event[offset] << endl;
  if(event[offset]==0xb0fe){
    //cout << "This should be b0fe " << event[offset] << endl;
    if(!fFoundBeginMarker) cout << "\n-->RBHINPUnpacker:: Using markers in VMUSB stack.\n";
    fFoundBeginMarker = kTRUE;
    offset+=2;
    
    //    // Skip to the next begin marker if there is one.
    //    UInt_t nextXLMWords = getLong(event,offset+1);
    //    if(nextXLMWords<event.size()){
    //      if(event[nextXLMWords]==0xb0fe){
    //        offset = offset + 1 + nextXLMWords + 1;
    //        if(reportNExtraMarkers%1000==0){
    //          cerr << "-->RBHINPUnpacker:: Found EXTRA markers!!! Data buffers are ill-defined. "
    //               << "           (this error will be partially suppressed.)" << endl;
    //        }
    //        reportNExtraMarkers++;
    //      }
    //      if(event[offset]==0xb0fe){
    //        nextXLMWords = getLong(event,offset+1);
    //        if(event[nextXLMWords]==0xb0fe) offset = offset + 1 + nextXLMWords + 1;
    //      }
    //    }
    //    offset+=2;
  }
  
  // Find the first XLM ID.
  if(event[offset]!=XLM1) cerr << "-->RBHINPUnpacker:: Did not find first XLM ID!" << endl;
  cout << "Here I am " << hex << event[offset] << endl;

  // Loop through the XLM bank IDs (i.e. the MB/Tower IDs)
  for(int bank=0; bank<fnMBs; bank++){
    cout << "I have this many MBs " << fnMBs << endl;
    xlmID[bank]           = event[offset];          offset++;
    //cout << "Here I am " << hex << event[offset] << endl;
    xlmWordCount[bank]    = getLong(event,offset);  offset+=2;
    //cout << "Here I am " << hex << event[offset] << endl;
    xlmChWordCount[bank]  = event[offset];          offset++;
    cout << "Bank number " << bank << " XLM channel count " << xlmChWordCount[bank] << endl;
    //cout << "Here I am " << hex << event[offset] << endl;
    
    fTimestamp[0] = getLong(event, offset);  offset+=2;
    //cout << "Here I am " << hex << event[offset] << endl;
    fTimestamp[1] = getLong(event, offset);  offset+=2;
    //cout << "Here I am " << hex << event[offset] << endl;
    
    //printf("%0.4x %0.4x %0.4x %0.4x %0.4x\n",xlmID[bank],xlmWordCount[bank],xlmChWordCount[bank],fTimestamp[0], fTimestamp[1]);
    
    // Check that the channel count is sane.
    // If it is not, then skip the RBHINPUnpacker unpacking of the current
    // VMUSB buffer.
    if(xlmChWordCount[bank]>4095){
      cerr << "-->RBHINPUnpacker:: Error from " << " - "
      << "Channel count = " << xlmChWordCount[bank] << endl;
      offset += xlmChWordCount[bank]*2 + 1;
      return offset;
    }
    
    // Loop over the channels
    UInt_t remainingWords = xlmWordCount[bank] - 5;
    for(int ch=0; ch<xlmChWordCount[bank]; ch++){
      //      channelIds32[bank].push_back(getLong(event,offset));
      channelIds16[bank].push_back(event[offset]);
      offset++;
      //cout << "Here I am " << hex << event[offset] << endl;
      remainingWords--;
    }
    // Read the remaining words, these should be XLM junk.
    for(int rWords=0; rWords<remainingWords; rWords++){
      UShort_t trailWord = event[offset];
      offset++;
      //cout << "Here I am " << hex << event[offset] << endl;
    }
    
    // By default, assume we are using the XLM ADCs
    // If we are using the XLM ADCs, then unpack them.
    if(!fUsingSISFADC){
      // Loop over the channels
      for(int ch=0; ch<xlmChWordCount[bank]; ch++){
        channelIds32[bank].push_back(getLong(event, offset));
        offset += 2;
      }
      for(int i=0; i<xlmChWordCount[bank]; i++) {
        // Get the time data
        if(offset >= event.size()){
          cerr << "-->RBHINPUnpacker:: Offset is larger than event buffer size!" << endl;
          break;
        }
        UInt_t time  = getLong(event, offset);
        offset        += 2;
        // Get the energy data
        if (offset >= event.size()){
          cerr << "-->RBHINPUnpacker:: Offset is larger than event buffer size!" << endl;
          break;
        }
        UInt_t energy  = getLong(event, offset);
        offset          += 2;
        
        UInt_t channelId = channelIds32[bank][i];
        UInt_t channel   = channelId & 0x0f;
        UInt_t chip      = (channelId >> 5) & 0xff;
        
	//The lines below are NOT commented out in SpecTcl CHINP.cpp
//        CTreeParameterArray** pChipTree = myParameters[bank][chip-1];
//        CTreeParameterArray*  pEs       = pChipTree[0];
//        CTreeParameterArray*  pTs       = pChipTree[1];
        
//        (*pEs)[channel] = energy;
//        (*pTs)[channel] = time;
      }
    }
  }
  
  // If we are using SIS FADCs, then unpack them.
  // The format of the longwords is shown in section 4.34
  // of the SIS manual.
  //
  //  ---------------------------------------------------------------------
  // | offset address | ADC   1   3   5   7      | ADC   2   4   6   8     |
  // |                | D31  D30      D29:16     | D15   D14     D13:0     |
  //  ---------------------------------------------------------------------
  // | 0x0            |  U  OR bit  14-bit data  |  G  OR bit  14-bit data |
  // | ..             |                          |                         |
  // | 0x7fffc        |  U  OR bit  14-bit data  |  G  OR bit  14-bit data |
  //  ---------------------------------------------------------------------
  //
  //
  if(fUsingSISFADC){
    // Check that we have a FADC ID
    if(event[offset] != 0xfadc){
      cout << "Here I am " << hex << event[offset] << endl;
      cerr << "-->RBHINPUnpacker:: Using FADC but did not find FADC ID! Found " << event[offset] <<endl;
      cerr.flush();
      return offset;
    }
    offset++;
    
    // Read the mask of read groups.
    // The low order four bits of this 16-bit data word describe which ADC groups are present.
    // If bit 0 is set, group 1 is present, if bit 1 is set group 2 and so on.
    fGroupMask = event[offset];  offset++;
    
    // Loop over the FADC channels
    // It is assumed that each XLM bank is matched to it's corresponding FADC channel group.
    for(int iADC=0; iADC<fnMBs; iADC++){
      UInt_t wordCount = getLong(event, offset); // Group size, not self-inclusive.
      offset += 2; // move to data
      
      // Check that the word count is sane.
      if(wordCount>1550) {
        cerr << "-->RBHINPUnpacker:: Error from " << " - wordCount = "
        << wordCount << endl;
        wordCount &= 0xfff;
        throw  std::string("bad event discarded.");
        return offset;
      }
      
      // Check that the word count is sane with the XLM channel count.
      // The word count should always = the XLM channel count.
      if (wordCount != xlmChWordCount[iADC]) {
        cerr << "-->RBHINPUnpacker:: Event size mismatch wordCount = " << wordCount
        << " channelCount = " << xlmChWordCount[iADC] << endl;
        throw  std::string("mismatch event discarded.");//commented out by Juan Sept 28, 2015 (temporarily)
        return offset;
      }
      
      // Loop over the FADC words
      for(int i=0; i<wordCount; i++){
        // Get the energy and time data.
        // A bitwise AND is applied to extract the 14-bit value.
        // !!! Currently E and T are reversed. This should be set using a flag.
        UShort_t time    = event[offset] & 0x3fff;  offset++;
        UShort_t energy  = event[offset] & 0x3fff;  offset++; energy = 16383 - energy;
        
        UShort_t channelId = channelIds16[iADC][i];
        UInt_t channel   = channelId & 0x0f;        // Lower 4 bits are the channel
        UInt_t chip      = (channelId >> 5) & 0xff; // 8 bits for chip ID
        
        UShort_t bank = iADC;
        AddHit(bank, channel, chip, energy, time);
	//This AddHit function replaces the code below to carry all of the data over
	//to the HiRA class

//        // Validate chip ID
//        if (chip > 0 && chip <= numChips) {
//          CTreeParameterArray** pChipTree = myParameters[iADC][chip-1];
//          CTreeParameterArray*  pEs       = pChipTree[0];
//          CTreeParameterArray*  pTs       = pChipTree[1];
//          
//          (*pEs)[channel] = energy;
//          (*pTs)[channel] = time;
//        }
      }
      // Check that we found the FADC trailer
      if(event[offset]!=0xaaaa){
        cerr << "RBHINPUnpacker:: Did not find FADC trailer for bank = " << iADC
        << ", found " << event[offset] << endl;
      }
      offset++;
    }
  }
  
  return offset;
}
