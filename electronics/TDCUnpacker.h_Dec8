//
//  RBCAEN1x90Unpacker.h
//

#ifndef __RBCAEN1x90UNPACKER_H
#define __RBCAEN1x90UNPACKER_H

#ifndef __RBMODULEUNPACKER_H
#include "RBModuleUnpacker.h"
#endif

#include <iostream>

#include "RBElectronics.h"

#include "TTree.h"

class RBCAEN1x90Unpacker : public RBModuleUnpacker, public RBElectronics
{
private:
  Int_t         fDepth;                             //!
  Int_t         fRefChannel;                        //!
  Int_t         fnChannels;                         //!
  Int_t         fChanmask;                          //!
  Int_t         fChanshift;                         //!
  Int_t         fDatamask;                          //!
  Double_t      fChsToNs;                           //!
  TString       fChName;                            //!
  Int_t         fnCh;                               //!
  Int_t         fTimes[128];
  
  TTree               *fChain;                 //! Pointer to current TTree or TChain
  Int_t                fCurrent;               //! Current Tree number in a TChain
  
public:
  RBCAEN1x90Unpacker():fDepth(1),fRefChannel(0),fnCh(128){fChName = "Ch";}
  RBCAEN1x90Unpacker(const char* chName, Int_t depth, Int_t refCh, Int_t nChannels, Double_t chsToNs=1);
  ~RBCAEN1x90Unpacker();
  
  Int_t   DecodeVSN(Int_t header);
  void    reportError(UInt_t errorWord, int slot);
  
  void    Clear(Option_t *option="");
  void    InitClass();
  void    InitBranch(TTree* tree);
  void    InitTree(TTree* tree);
  Int_t   Unpack(std::vector<UShort_t>& event, UInt_t offset);
  
  Int_t   *GetData()        {return fTimes;}
  Int_t    GetData(Int_t ch){
    //    std::cout << "Inside GetData for ch " << ch << " is " << fTimes[ch] << std::endl;
    return fTimes[ch];
  }
  Int_t    GetAllData(){
    for (int i = 0; i<128; i++){
      if (fTimes[i] < 999) {
	std::cout << "At position " << i << " we have " << fTimes[i] << std::endl;
      }
    }
    return fTimes[96];
  }
  Int_t    GetRefChannel(){return fRefChannel;}

  
  ClassDef(RBCAEN1x90Unpacker,1);
};

#endif
